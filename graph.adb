-- Authors: Spencer Hirsch, shirsch2020@my.fit.edu
--          Tyler Gutowski, tgutowski2020@my.fit.edu
-- Course:  CSE 4250, Fall 2022
-- Project: Project 3, Can you HEAR me now?


-- PACKAGE HANDLES ALL OF THE DATA IN RELATION TO THE GRAPH. THIS IS USED
-- FOR CLEANER AND BETTER TO MANAGE CODE.

-- FUNCTIONS ARE CALLED FROM HEAR.ADB TO PROCESS THE DATA ACCORDINGLY.

PACKAGE BODY GRAPH IS
	-- RETURNS BOOLEAN GIVEN THE NAME OF THE SOURCE. CHECKS TO SEE IF SOURCE
	-- EXISTS WITHIN THE SOURCE LIST
	FUNCTION EXISTS_IN_SOURCE (TOWER_FIRST_NAME : STRING) RETURN BOOLEAN IS
	EXISTS : BOOLEAN := FALSE;						-- DECLARATION
	CURRENT_CURSOR : CURSOR;
	CURRENT_TOWER : TOWERS_ACCESS;
	IS_EMPTY_LIST : BOOLEAN := FALSE;
	BEGIN
		IS_EMPTY_LIST := IS_EMPTY(SOURCES);
		IF IS_EMPTY_LIST THEN
			RETURN EXISTS;							-- IF EMPTY, DOESN'T EXIST
		END IF;
		CURRENT_CURSOR := FIRST(SOURCES);			-- ELSE, CHECK
		FOR I IN 1..LENGTH(SOURCES) LOOP
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);	-- ITERATE
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				EXISTS := TRUE;	
				RETURN EXISTS;							-- IF FOUND
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);	-- ELSE, CONTINUE
			END IF;
		END LOOP;
		RETURN EXISTS;								-- RETURNS FALSE
	END EXISTS_IN_SOURCE;
	

	-- RETURNS TOWER_ACCESS TYPE GIVEN THE FIRST NAME OF THE SOURCE
	FUNCTION GET_FROM_SOURCE ( TOWER_FIRST_NAME : STRING ) RETURN TOWERS_ACCESS IS
	CURRENT_CURSOR : CURSOR;					-- DECLARIZATION
	CURRENT_TOWER : TOWERS_ACCESS := NULL;
	BEGIN
		CURRENT_CURSOR := FIRST(SOURCES);		-- INITIALIZE
		FOR I IN 1..LENGTH(SOURCES) LOOP		
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);	-- GET VALUE OF FIRST TOWER
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				RETURN CURRENT_TOWER;		-- IF FOUND
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);		-- ITERATE
			END IF;
		END LOOP;
		RETURN NULL;	-- NOT FOUND
	END GET_FROM_SOURCE;
	

	-- SEARCH ALGORITH TO FIND INDIRECT MATCHES WITHIN THE GRAPH. USES RECURSION TO SEARCH THE TREE.
	-- IF FOUND, OUTPUTS TO THE CONSOLE THE DESIRED OUTPUT FOR THE OPERATION PREFORMED ON THE GRAPH.
	PROCEDURE DFS (TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING; TRUE_TOWER_FIRST_NAME : STRING) IS
	CURRENT : TOWERS_ACCESS;
	TOWER_EXISTS_IN_SOURCE : BOOLEAN;
	TOWER_CURRENT : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME); -- FIND THE SOURCE TOWER OBJECT
		CURRENT.CHECKED := TRUE;
		-- PASS CONDITION
		IF CURRENT.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) AND ALREADY_PRINTED_DFS = FALSE  THEN -- IF YOU ARE SEARCHING THE TOWER YOU WANT
			ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
			ALREADY_PRINTED_DFS := TRUE;
		
		-- RECURSE
		ELSE
			FOR TOWER OF CURRENT.LINK LOOP -- FOR ALL LINKS IN SOURCE
				TOWER_EXISTS_IN_SOURCE := EXISTS_IN_SOURCE(TO_STRING(TOWER.SOURCE));
				IF TOWER_EXISTS_IN_SOURCE THEN
					TOWER_CURRENT := GET_FROM_SOURCE(TO_STRING(TOWER.SOURCE));
					IF NOT TOWER_CURRENT.CHECKED THEN -- IF THE LINK HASN'T BEEN CHECKED
						IF TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) THEN -- IF WE ARE AT END
							ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
							ALREADY_PRINTED_DFS := TRUE;
						END IF;
						IF ALREADY_PRINTED_DFS = FALSE THEN -- IF TOWER DOES EXIST, WE ARE NOT AT THE END. CONTINUE RECURSING.
							DFS(TO_STRING(TOWER.SOURCE), TOWER_SECOND_NAME, TRUE_TOWER_FIRST_NAME);
						END IF;
					END IF;
				ELSE
					IF TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) THEN -- IF WE ARE AT END
						ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
						ALREADY_PRINTED_DFS := TRUE;
					END IF; 
				END IF;
			END LOOP;
		END IF;
		
		-- IF YOU ARE AT THE ROOT TOWER AND YOU HAVENT PRINTED ALREADY
		IF TOWER_FIRST_NAME = TRUE_TOWER_FIRST_NAME AND ALREADY_PRINTED_DFS = FALSE THEN
			ADA.TEXT_IO.PUT_LINE("- " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
		END IF;
	END DFS;

	PROCEDURE RESET_CHECKED_SOURCES IS
	ITEM_ACCESS : TOWERS_ACCESS;
	BEGIN
		-- For each item in the "sources" list
		FOR ITEM OF SOURCES LOOP
			-- Point to each item, and set them to not checked yet.
			ITEM_ACCESS := GET_FROM_SOURCE(TO_STRING(ITEM.SOURCE));
			ITEM_ACCESS.CHECKED := FALSE;
			-- For each linked item for each source
			FOR CHILD OF ITEM.LINK LOOP
				CHILD.CHECKED := FALSE;
			END LOOP;
		END LOOP;
	END RESET_CHECKED_SOURCES;

	-- GIVEN A SOURCE NAME AND A DESTINATION NAME, THIS FUNCTION CHECKS TO SEE IF A CONNECTING TOWER
	-- IS A DIRECT CONNECTION WITH THE SOURCE TOWER. RETURNS A BOOLEAN IF THE CONNECTING TOWER IS
	-- CONTAINED WITHIN THE LIST IN THE TOWERS_ACCESS RECORD
	FUNCTION CHECK_TOWER_LIST(TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING) RETURN BOOLEAN IS
	FOUND : BOOLEAN := FALSE;							-- DECLARIZATION
	CURRENT_CURSOR : CURSOR;
	CURRENT : TOWERS_ACCESS;
	CURRENT_IN_TOWER : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME);	-- INITIALIZE
		CURRENT_CURSOR := CURRENT.LINK.FIRST;
		FOR I IN 1..LENGTH(CURRENT.LINK) LOOP			-- ITERATE
			CURRENT_IN_TOWER := ELEMENT(CURRENT_CURSOR);
			IF TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) = CURRENT_IN_TOWER.SOURCE THEN
				FOUND := TRUE;
				RETURN FOUND;							-- RETURNS IF FOUND
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN FOUND;									-- VALUE NOT FOUND
	END CHECK_TOWER_LIST;


	-- FUNCTION USED TO CHECK ALL POSSIBLE CONNECTS FROM A PARENT SOURCE
	-- EXAMPLE INPUT:
	-- TOWER1 TOWER2 .
	-- TOWER2 TOWER3 .
	-- TOWER1 TOWER3 ? SHOULD RETURN:
	-- + TOWER1 => TOWER3
	-- THIS FUNCTION COVERS THAT CASE A RETURNS
	-- @PARAM DOES_EXIST OF TYPE BOOLEAN
	FUNCTION CHECK_ALL_POSSIBLE(TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING) RETURN BOOLEAN IS
		DOES_EXIST : BOOLEAN := FALSE;					-- DECLARIZATION
		CURRENT_CURSOR : CURSOR;
		CURRENT : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME);	-- INITIALIZATION
		CURRENT_CURSOR := CURRENT.LINK.FIRST;
		FOR I IN 1..LENGTH(CURRENT.LINK) LOOP			-- ITERATE
			CURRENT := ELEMENT(CURRENT_CURSOR);
			DOES_EXIST := CHECK_TOWER_LIST(TO_STRING(CURRENT.SOURCE), TOWER_SECOND_NAME);
			IF DOES_EXIST THEN
				RETURN DOES_EXIST;						-- IF FOUND, RETURNS TRUE
			END IF;
		END LOOP;
		RETURN DOES_EXIST;								-- ELSE, RETURNS FALSE
	END CHECK_ALL_POSSIBLE;		
END GRAPH;
